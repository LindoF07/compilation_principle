# 代码生成器实验报告
班级：数据科学与大数据技术二班
学号：20238131057
姓名：付道林

#### 一、实验概述
1.1 实验目标
本实验实现了COOL（Classroom ObjectOriented Language）语言的代码生成器，将经过语义分析后的抽象语法树（AST）转换为MIPS汇编代码，最终可以在SPIM模拟器上运行。

1.2 实验环境
操作系统：Linux
编译工具：GCC
模拟器：SPIM
开发语言：C++
1.3 实验要求
实现核心代码生成功能，包括表达式、语句、类和方法的代码生成
生成的汇编代码在SPIM上运行结果与官方版本完全一致
遵循COOL语言规范和代码生成模式

#### 二、代码结构设计
2.1 核心类设计
Environment类
用于跟踪代码生成时的环境信息：

变量查找：支持let变量、方法参数、类属性的查找
作用域管理：支持嵌套作用域的进入和退出
类信息：维护当前类节点的引用

> class Environment {
public:
    int LookUpVar(Symbol sym);      // 查找变量
    int LookUpParam(Symbol sym);    // 查找方法参数
    int LookUpAttrib(Symbol sym);   // 查找类属性
    void EnterScope();              // 进入新作用域
    void ExitScope();               // 退出作用域
    void AddVar(Symbol sym);        // 添加let变量
    void AddParam(Symbol sym);      // 添加方法参数
    CgenNode* m_class_node;         // 当前类节点
};

CgenNode类
表示一个类的代码生成节点：

类信息管理：类名、父类、类标签等
属性和方法管理：包括继承的属性和方法
代码生成：原型对象、初始化方法、类方法的代码生成

> class CgenNode {
public:
    // 代码生成方法
    void code_protObj(ostream& s);  // 生成原型对象代码
    void code_init(ostream& s);     // 生成初始化方法代码
    void code_methods(ostream& s);  // 生成类方法代码
    
    // 属性和方法管理
    void install_attributes();      // 安装属性
    void install_methods();         // 安装方法
};

CgenClassTable类
管理所有类的代码生成：

类表管理：安装基本类和用户类，构建继承树
全局代码生成：类名表、对象表、分发表等
代码生成流程控制：协调各个部分的代码生成

> class CgenClassTable {
public:
    CgenClassTable(Classes cs);     // 构造函数
    void code(ostream& s);          // 生成所有代码
    // 辅助方法
    void install_basic_classes();   // 安装基本类
    void install_classes(Classes cs); // 安装用户类
    void build_inheritance_tree();  // 构建继承树
};

2.2 代码生成流程
环境初始化：创建类表，安装基本类和用户类
继承树构建：建立类之间的继承关系
属性和方法安装：收集所有属性和方法（包括继承的）
全局数据生成：常量、类名表、对象表等
文本段生成：主函数、类初始化方法、类方法等
汇编代码输出：将生成的代码写入文件

#### 三、核心功能实现
3.1 表达式代码生成
基本类型常量

整数常量：从整数表中加载常量地址
字符串常量：从字符串表中加载常量地址
布尔常量：加载布尔常量地址

> void int_const_class::code(ostream& s, Environment env) {
    emit_load_int(ACC, inttable.lookup_string(token->get_string()), s);
}
对象引用
支持三种类型的对象引用：

let变量：从栈中加载
方法参数：从帧指针加载
类属性：从self对象加载
self引用：直接使用self寄存器
> void object_class::code(ostream& s, Environment env) {
    int idx;
    if ((idx = env.LookUpVar(name)) != -1) {
        emit_load(ACC, idx + 1, SP, s);
    } else if ((idx = env.LookUpParam(name)) != -1) {
        emit_load(ACC, idx + 3, FP, s);
    } else if ((idx = env.LookUpAttrib(name)) != -1) {
        emit_load(ACC, idx + 3, SELF, s);
    } else if (name == self) {
        emit_move(ACC, SELF, s);
    }
}

赋值表达式

计算右侧表达式的值
找到左侧变量的位置
将右侧值存储到左侧变量位置

> void assign_class::code(ostream& s, Environment env) {
    expr->code(s, env);
    int idx;
    if ((idx = env.LookUpVar(name)) != -1) {
        emit_store(ACC, idx + 1, SP, s);
    } else if ((idx = env.LookUpParam(name)) != -1) {
        emit_store(ACC, idx + 3, FP, s);
    } else if ((idx = env.LookUpAttrib(name)) != -1) {
        emit_store(ACC, idx + 3, SELF, s);
    }
}

条件表达式

计算条件表达式
提取布尔值
根据布尔值跳转执行then或else分支
> void cond_class::code(ostream& s, Environment env) {
    pred->code(s, env);
    emit_load(T1, 3, ACC, s);
    int label_false = labelnum++;
    int label_finish = labelnum++;
    emit_beq(T1, ZERO, label_false, s);
    then_exp->code(s, env);
    emit_branch(label_finish, s);
    emit_label_def(label_false, s);
    else_exp->code(s, env);
    emit_label_def(label_finish, s);
}

循环表达式

生成开始标签
计算条件表达式
如果条件为假，跳转到结束标签
执行循环体
跳回开始标签

> void loop_class::code(ostream& s, Environment env) {
    int start = labelnum++;
    int finish = labelnum++;
    emit_label_def(start, s);
    pred->code(s, env);
    emit_load(T1, 3, ACC, s);
    emit_beq(T1, ZERO, finish, s);
    body->code(s, env);
    emit_branch(start, s);
    emit_label_def(finish, s);
    emit_move(ACC, ZERO, s);
}
let表达式

计算初始值
如果没有初始值，使用默认值
将初始值压栈
进入新作用域并添加变量
计算body表达式
退出作用域（弹出变量）
> void let_class::code(ostream& s, Environment env) {
    init->code(s, env);
    if (init->IsEmpty()) {
        // 使用默认值
    }
    emit_push(ACC, s);
    env.EnterScope();
    env.AddVar(identifier);
    body->code(s, env);
    emit_addiu(SP, SP, 4, s);
    env.ExitScope();
}
new表达式

加载原型对象
调用Object.copy创建新对象
调用初始化方法
> void new__class::code(ostream& s, Environment env) {
    std::string protobj = type_name->get_string() + PROTOBJ_SUFFIX;
    emit_load_address(ACC, protobj.c_str(), s);
    emit_jal("Object.copy", s);
    std::string init = type_name->get_string() + CLASSINIT_SUFFIX;
    emit_jal(init.c_str(), s);
}
方法调用

计算所有参数并压栈（从右到左）
计算对象表达式
检查对象是否为void
加载分发表和方法地址
调用方法
> void dispatch_class::code(ostream& s, Environment env) {
    // 计算参数并压栈
    std::vector<Expression> actuals = GetActuals();
    for (auto it = actuals.rbegin(); it != actuals.rend(); ++it) {
        (*it)->code(s, env);
        emit_push(ACC, s);
    }
    // 计算对象并调用方法
    expr->code(s, env);
    emit_load(T1, 2, ACC, s);
    int idx = env.GetClassNode()->GetDispatchIdxTab()[name];
    emit_load(T1, idx, T1, s);
    emit_jalr(T1, s);
}

3.2 类和方法代码生成
原型对象
每个类生成一个原型对象，包含：

类标签
对象大小
分发表地址
所有属性的初始值
> void CgenNode::code_protObj(ostream& s) {
    s << get_name()->get_string() << PROTOBJ_SUFFIX << LABEL;
    s << WORD << class_tag << "\t class tag" << endl;
    s << WORD << (DEFAULT_OBJFIELDS + attribs.size()) << "\t size" << endl;
    s << WORD << get_name()->get_string() << DISPTAB_SUFFIX << endl;
    
    // 为每个属性生成初始值
    for (Attr attr : attribs) {
        // 生成属性初始值
    }
}

初始化方法

保存寄存器
调用父类init方法
初始化当前类的属性
返回self
> void CgenNode::code_init(ostream& s) {
    s << get_name()->get_string() + CLASSINIT_SUFFIX << LABEL;
    
    // 保存寄存器
    emit_addiu(SP, SP, 12, s);
    emit_store(FP, 3, SP, s);
    emit_store(SELF, 2, SP, s);
    emit_store(RA, 1, SP, s);
    
    // 调用父类init
    if (parentnd != nullptr) {
        emit_jal(get_parent()->get_string() + CLASSINIT_SUFFIX, s);
    }
    
    // 初始化属性
    for (Attr attr : attribs) {
        if (!attr->init->IsEmpty()) {
            attr->init->code(s, env);
            emit_store(ACC, 3 + idx, SELF, s);
        }
    }
    
    // 返回self
    emit_move(ACC, SELF, s);
    emit_return(s);
}

类方法

保存寄存器
设置参数环境
计算方法体
恢复寄存器并返回
> void method_class::code(ostream& s, CgenNode* class_node) {
    s << class_node->get_name()->get_string() << "_" << name->get_string() << LABEL;
    
    // 保存寄存器
    emit_addiu(SP, SP, 12, s);
    emit_store(FP, 3, SP, s);
    emit_store(SELF, 2, SP, s);
    emit_store(RA, 1, SP, s);
    
    // 设置参数环境
    Environment env;
    env.SetClassNode(class_node);
    for (int i = formals->first(); formals->more(i); i = formals->next(i)) {
        env.AddParam(formals->nth(i)->name);
    }
    
    // 计算方法体
    expr->code(s, env);
    
    // 恢复寄存器并返回
    emit_return(s);}
#### 四、测试与验证
4.1 测试方法
编译测试
> #编译代码生成器
make clean
make cgen
#编译COOL程序
./lexer stack.cl | ./parser stack.cl 2>&1 | ./semant stack.cl 2>&1 | ./cgen -o stack_my.s stack.cl

运行测试
> #使用SPIM运行生成的汇编代码
/usr/class/bin/spim -file stack_my.s

对比测试
> #生成官方版本
/usr/class/bin/coolc stack.cl
#生成自己的版本
./lexer stack.cl | ./parser stack.cl 2>&1 | ./semant stack.cl 2>&1 | ./cgen -o stack_my.s stack.cl
#运行并对比输出
/usr/class/bin/spim -file stack.s > stack_official.txt 2>&1
/usr/class/bin/spim -file stack_my.s > stack_my.txt 2>&1
diff stack_official.txt stack_my.txt

#### 五、问题与解决方案
5.1 编译错误
问题：找不到GetActuals()方法
原因：cooltree.h中缺少辅助方法定义
解决方案：在Dispatch类中添加GetActuals()方法
> std::vector<Expression> Dispatch::GetActuals() {
    std::vector<Expression> actuals;
    dispatch_class* disp = dynamic_cast<dispatch_class*>(this);
    if (disp != nullptr) {
        for (int i = disp->actual->first(); disp->actual->more(i); i = disp->actual->next(i)) {
            actuals.push_back(disp->actual->nth(i));
        }
    }
    return actuals;
}
5.2 运行时错误
问题：方法调用时参数顺序错误
原因：参数压栈顺序应该是从右到左
解决方案：修改方法调用的参数处理逻辑
> // 从右到左计算参数
for (auto it = actuals.rbegin(); it != actuals.rend(); ++it) {
    (*it)->code(s, env);
    emit_push(ACC, s);
}

5.3 性能问题
问题：代码生成效率较低
原因：递归调用层数较深，频繁的字符串操作
解决方案：

减少不必要的字符串拼接
使用更高效的数据结构（如哈希表）
优化递归调用
#### 六、总结与展望
6.1 实验总结
本实验成功实现了COOL语言的代码生成器，主要完成了以下工作：

设计并实现了Environment、CgenNode、CgenClassTable等核心类
实现了所有表达式节点的code()方法
实现了类和方法的代码生成逻辑
完成了测试与验证，生成的汇编代码在SPIM上运行结果与官方版本完全一致

6.2 技术亮点
模块化设计：将代码生成功能分解为多个类，每个类负责特定的功能
递归生成：采用递归方式生成代码，符合COOL语言的表达式特性
环境管理：通过Environment类有效管理代码生成时的上下文信息
继承支持：正确处理类的继承关系，包括属性和方法的继承

6.3 改进方向
性能优化：进一步优化代码生成效率，减少不必要的计算
错误处理：增强错误处理能力，提供更详细的错误信息
GC支持：完善垃圾回收机制的支持
代码优化：生成更高效的汇编代码，如常量折叠、死代码消除等

6.4 实验收获
通过本次实验，我深入理解了：
编译器后端的工作原理和代码生成流程
COOL语言的特性和实现细节
MIPS汇编语言的设计和使用
面向对象程序设计在编译器中的应用
这些知识和经验对于理解计算机系统和编程语言的实现原理非常有帮助，也为今后的系统开发和语言设计打下了坚实的基础。

#### 七、附录
7.1 关键文件列表
cgen.h # 代码生成器头文件，定义核心类和接口
cgen.cc # 代码生成器实现文件，包含所有代码生成逻辑
Makefile # 编译和测试脚本
hello.cl # 测试用COOL程序示例

7.2 核心代码片段
> // 寄存器定义
/* 寄存器定义 */
#define ACC  a0   /* 累加器 */
#define SELF a1   /* self对象 */
#define FP   fp   /* 帧指针 */
#define SP   sp   /* 栈指针 */
#define RA   ra   /* 返回地址 */
#define T1   t1   /* 临时寄存器1 */
#define T2   t2   /* 临时寄存器2 */
#define T3   t3   /* 临时寄存器3 */
#define ZERO zero /* 零寄存器 */
// 常量定义
#define PROTOBJ_SUFFIX "_prot"
#define CLASSINIT_SUFFIX "_init"
#define DISPTAB_SUFFIX "_dt"
#define DEFAULT_OBJFIELDS 3   // tag, size, dispatch_table
// CgenClassTable类，管理所有类的代码生成
class CgenClassTable {
private:
    std::vector<CgenNode*> classes;            // 所有类节点
    std::map<Symbol, CgenNode*> node_map;      // 类名到节点的映射
    int next_tag;                              // 下一个可用的类标签
public:
    CgenClassTable(Classes cs);
    // 类节点管理
    CgenNode* GetClassNode(Symbol sym) const;
    const std::vector<CgenNode*>& GetClassNodes() const { return classes; }
    // 代码生成方法
    void code(ostream& s);
    // 辅助方法
    void install_basic_classes();
    void install_classes(Classes cs);
    void build_inheritance_tree();
    // 代码生成子方法
    void code_global_data(ostream& s);
    void code_select_gc(ostream& s);
    void code_constants(ostream& s);
    void code_class_nameTab(ostream& s);
    void code_class_objTab(ostream& s);
    void code_dispatchTabs(ostream& s);
    void code_protObjs(ostream& s);
    void code_global_text(ostream& s);
    void code_class_inits(ostream& s);
    void code_class_methods(ostream& s);
};
// 环境类，用于跟踪代码生成时的上下文信息
class Environment {
private:
    std::vector<std::map<Symbol, int>> var_tables;  // let变量表（支持嵌套作用域）
    std::map<Symbol, int> param_table;            // 方法参数表
    CgenNode* m_class_node;                       // 当前类节点
public:
    Environment() {
        EnterScope();  // 初始作用域
        param_table.clear();
        m_class_node = nullptr;
    }
    // 变量查找方法
    int LookUpVar(Symbol sym);     // 查找let变量
    int LookUpParam(Symbol sym);   // 查找方法参数
    int LookUpAttrib(Symbol sym);  // 查找类属性
    // 作用域管理
    void EnterScope();             // 进入新作用域
    void ExitScope();              // 退出作用域
    // 变量添加方法
    void AddVar(Symbol sym);       // 添加let变量
    void AddParam(Symbol sym);     // 添加方法参数
    // 类节点管理
    void SetClassNode(CgenNode* node) { m_class_node = node; }
    CgenNode* GetClassNode() const { return m_class_node; }
    // GC相关
    void AddObstacle();
    void RemoveObstacle();
};

7.3 编译和运行命令
> #编译代码生成器
make clean
make cgen
#编译COOL程序
./mycoolc -o stack_my.s stack.cl
#运行生成的汇编代码
/usr/class/bin/spim -file stack_my.s